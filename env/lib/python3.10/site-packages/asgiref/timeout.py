import asyncio
import warnings
from typing import Any
from typing import Optional
from typing import Type
from typing import Union


class TimeoutError(BaseException):
    pass


class Timeout:
    """Timeout context manager.

    Useful in cases when you want to apply timeout logic around a block
    of code or in cases when asyncio.wait_for is not suitable.

    Example:
        >>> with Timeout(0.001):
        ...     async with aiohttp.get('https://github.com') as r:
        ...         await r.text()

    Args:
        timeout: Value in seconds or None to disable timeout logic
        loop: Asyncio compatible event loop
    """

    def __init__(
        self,
        timeout: Optional[float] = None,
        loop: Optional[asyncio.AbstractEventLoop] = None,
    ) -> None:
        self._timeout = timeout
        if loop is None:
            loop = asyncio.get_running_loop()
        else:
            warnings.warn(
                """The loop argument to Timeout() is deprecated.""", DeprecationWarning
            )
        self._loop = loop
        self._task = None  # type: Optional[asyncio.Task[Any]]
        self._cancelled = False
        self._cancel_handler = None  # type: Optional[asyncio.Handle]
        self._cancel_at = None  # type: Optional[float]

    def __enter__(self) -> "Timeout":
        return self._do_enter()

    def __exit__(
        self,
        exc_type: Type[BaseException],
        exc_val: BaseException,
        exc_tb: TracebackType,
    ) -> Optional[bool]:
        self._do_exit(exc_type)
        return None

    async def __aenter__(self) -> "Timeout":
        return self._do_enter()

    async def __aexit__(
        self,
        exc_type: Type[BaseException],
        exc_val: BaseException,
        exc_tb: TracebackType,
    ) -> None:
        self._do_exit(exc_type)

    @property
    def expired(self) -> bool:
        """Return True if the timeout has been reached, False otherwise."""
        return self._cancelled

    @property
    def remaining(self) -> Union[float, None]:
        """Return the remaining time until the timeout, or None if the timeout is disabled."""
        if self._cancel_at is not None:
            remaining = self._cancel_at - self._loop.time()
            if remaining > 0:
                return remaining
        return None

    def cancel(self) -> None:
        """Cancel the timeout explicitly."""
        if self._cancel_handler is not None:
            self._cancel_handler.cancel()
            self._cancel_handler = None

    def _do_enter(self) -> "Timeout":
        # Support Tornado 5- without timeout
        # Details: https://github.com/python/asyncio/issues/392
        if self._timeout is None:
            return self

        self._task = asyncio.current_task(self._loop)
        if self._task is None:
            raise RuntimeError(
                "Timeout context manager should be used inside a task"
            )

        if self._timeout <= 0:
            self._loop.call_soon(self._cancel_task)
            return self

        self._cancel_at = self._loop.time() + self._timeout
        self._cancel_handler = self._loop.call_at(self._cancel_at, self._cancel_task)
        return self

    def _do_exit(self, exc_type: Type[BaseException]) -> None:
        if exc_type is asyncio.CancelledError and self._cancelled:
            self._cancel_handler = None
            self._task = None
            raise TimeoutError
        if self._timeout is not None and self._cancel_handler is not None:
            self._cancel_handler.cancel()
            self._cancel_handler = None
        self._task = None

    def _cancel_task(self) -> None:
        if self._task is not None:
            self._task.cancel()
            self._cancelled = True

    def __del__(self) -> None:
        if self._cancel_handler is not None:
            warnings.warn(
                "Timeout context manager was not exited properly. "
                "The timeout may not have been cancelled.",
                UserWarning,
            )
