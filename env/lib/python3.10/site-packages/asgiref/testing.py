import asyncio
import contextvars
import time
from typing import Any
from typing import Callable
from typing import Coroutine
from typing import Optional

from .compatibility import guarantee_single_callable
from .timeout import timeout as async_timeout

class ApplicationCommunicator:
    """
    Runs an ASGI application in a test mode, allowing sending of
    messages to it and retrieval of messages it sends.
    """

    def __init__(self, application: Callable[[dict, Callable, Callable], Coroutine[Any, Any, Any]], scope: dict):
        self.application = guarantee_single_callable(application)
        self.scope = scope
        self.input_queue = asyncio.Queue()
        self.output_queue = asyncio.Queue()
        self.future = asyncio.run(
            asyncio.create_task(
                self.application(scope, self.input_queue.get, self.output_queue.put)
            )
        )

    async def wait(self, timeout: float = 1) -> Optional[Exception]:
        """
        Waits for the application to stop itself and returns any exceptions.
        """
        try:
            await asyncio.wait_for(self.future, timeout)
        except asyncio.TimeoutError:
            self.future.cancel()
            await self.future
            return TimeoutError("Application did not stop within timeout")
        except asyncio.CancelledError:
            return None

    def stop(self, exceptions: bool = True):
        if not self.future.done():
            self.future.cancel()
        elif exceptions:
            self.future.result()

    def __del__(self):
        try:
            self.stop(exceptions=False)
        except RuntimeError:
            pass

    async def send_input(self, message: Any):
        """
        Sends a single message to the application
        """
        await self.input_queue.put(message)

    async def receive_output(self, timeout: float = 1) -> Any:
        """
        Receives a single message from the application, with optional timeout.
        """
        await asyncio.wait_for(self.future, timeout)
        return await self.output_queue.get()

    async def receive_nothing(self, timeout: float = 0.1, interval: float = 0.01) -> bool:
        """
        Checks that there is no message to receive in the given time.
        """
        await asyncio.sleep(timeout)
        return self.output_queue.empty()
