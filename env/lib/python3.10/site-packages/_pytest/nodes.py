import abc
import os
import pathlib
from functools import cached_property
from inspect import signature
from typing import Any
from typing import Callable
from typing import cast
from typing import Iterable
from typing import Iterator
from typing import List
from typing import MutableMapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from warnings import warn

import pluggy

if TYPE_CHECKING:
    from _pytest._code.code import _TracebackStyle
    from _pytest.main import Session

SEP = "/"
tracebackcutdir = pathlib.Path(_pytest.__file__).parent

_T = TypeVar("_T")


def _imply_path(
    node_type: Type["Node"],
    path: Optional[pathlib.Path],
    fspath: Optional[str],
) -> pathlib.Path:
    if fspath is not None:
        warn(
            NODE_CTOR_FSPATH_ARG.format(
                node_type_name=node_type.__name__,
            ),
            stacklevel=6,
        )
    if path is not None:
        if fspath is not None:
            _check_path(path, fspath)
        return path
    else:
        assert fspath is not None
        return pathlib.Path(fspath)


class NodeMeta(abc.ABCMeta):
    def __call__(cls, *k, **kw) -> NoReturn:
        msg = (
            "Direct construction of {name} has been deprecated, please use {name}.from_parent.\n"
            "See "
            "https://docs.pytest.org/en/stable/deprecations.html#node-construction-changed-to-node-from-parent"
            " for more details."
        ).format(name=f"{cls.__module__}.{cls.__name__}")
        raise AssertionError(msg)


class Node(abc.ABC, metaclass=NodeMeta):
    __slots__ = (
        "name",
        "parent",
        "config",
        "session",
        "path",
        "_nodeid",
        "_store",
        "__dict__",
    )

    def __init__(
        self,
        name: str,
        parent: Optional["Node"] = None,
        config: Optional["Config"] = None,
        session: Optional["Session"] = None,
        fspath: Optional[str] = None,
        path: Optional[pathlib.Path] = None,
        nodeid: Optional[str] = None,
    ) -> None:
        self.name: str = name
        self.parent = parent

        if config:
            self.config: Config = config
        else:
            if not parent:
                raise TypeError("config or parent must be provided")
            self.config = parent.config

        if session:
            self.session: Session = session
        else:
            if not parent:
                raise TypeError("session or parent must be provided")
            self.session = parent.session

        self.path: pathlib.Path = _imply_path(type(self), path, fspath=fspath)
        self.keywords: MutableMapping[str, Any] = NodeKeywords(self)
        self.own_markers: List[Mark] = []
        self.extra_keyword_matches: Set[str] = set()

        if nodeid is not None:
            assert "::()" not in nodeid
            self._nodeid = nodeid
        else:
            if not self.parent:
                raise TypeError("nodeid or parent must be provided")
            self._nodeid = self.parent.nodeid + "::" + self.name

        self.stash: Stash = Stash()
        self._store = self.stash

