import atexit
import contextlib
import fnmatch
import os
import shutil
import stat
import sys
import types
from enum import Enum
from pathlib import Path
from posixpath import sep as posix_sep
from typing import (
    Any,
    Callable,
    Iterable,
    Iterator,
    List,
    Optional,
    Tuple,
    Type,
    TypeVar,
    Union,
)

if sys.platform.startswith("win32"):
    sep = "\\"
else:
    sep = posix_sep

LOCK_TIMEOUT = 60 * 60 * 24 * 3

_IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)
_IGNORED_WINERRORS = (21, 1921)


def _ignore_error(exception: BaseException) -> bool:
    return (
        getattr(exception, "errno", None) in _IGNORED_ERRORS
        or getattr(exception, "winerror", None) in _IGNORED_WINERRORS
    )


def get_lock_path(path: Path) -> Path:
    return path.joinpath(".lock")


def on_rm_rf_error(
    func: Callable,
    path: str,
    excinfo: Union[BaseException, Tuple[Type[BaseException], BaseException]],
    *,
    start_path: Path,
) -> bool:
    if isinstance(excinfo, BaseException):
        exc = excinfo
    else:
        exc = excinfo[1]

    if isinstance(exc, FileNotFoundError):
        return False

    if not isinstance(exc, PermissionError):
        warnings.warn(
            PytestWarning(f"(rm_rf) error removing {path}\n{type(exc)}: {exc}")
        )
        return False

    if func not in (os.rmdir, os.remove, os.unlink, os.open):
        warnings.warn(
            PytestWarning(
                f"(rm_rf) unknown function {func} when removing {path}:\n{type(exc)}: {exc}"
            )
        )
        return False

    mode = os.stat(path).st_mode
    os.chmod(path, mode | stat.S_IRUSR | stat.S_IWUSR)

    func(path)
    return True


def ensure_extended_length_path(path: Path) -> Path:
    if sys.platform.startswith("win32"):
        path = path.resolve()
        path = Path(get_extended_length_path_str(str(path)))
    return path


def get_extended_length_path_str(path: str) -> str:
    long_path_prefix = "\\\\?\\"
    unc_long_path_prefix = "\\\\?\\UNC\\"
    if path.startswith((long_path_prefix, unc_long_path_prefix)):
        return path
    if path.startswith("\\\\"):
        return unc_long_path_prefix + path[2:]
    return long_path_prefix + path


def rm_rf(path: Path) -> None:
    path = ensure_extended_length_path(path)
    onerror = partial(on_rm_rf_error, start_path=path)
    shutil.rmtree(str(path), onexc=onerror)


def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry]:
    l_prefix = prefix.lower()
    for x in os.scandir(root):
        if x.name.lower().startswith(l_prefix):
            yield x


def extract_suffixes(iter: Iterable[os.DirEntry], prefix: str) -> Iterator[str]:
    p_len = len(prefix)
    for entry in iter:
        yield entry.name[p_len:]


def find_suffixes(root: Path, prefix: str) -> Iterator[str]:
    return extract_suffixes(find_prefixed(root, prefix), prefix)


def parse_num(maybe_num: str) -> int:
    try:
        return int(maybe_num)
    except ValueError:
        return -1


def _force_symlink(
    root: Path, target: Union[str, Path], link_to: Union[str, Path]
) -> None:
    current_symlink = root.joinpath(target)
    try:
        current_symlink.unlink()
    except OSError:
        pass
    try:
        os.symlink(str(link_to), str(current_symlink))
    except Exception:
        pass


def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:
    for i in range(10):
        max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath(f"{prefix}{new_number}")
        try:
            new_path.mkdir(mode=mode)
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise OSError(
            "could not create numbered dir with prefix "
            f"{prefix} in {root} after 10 tries"
        )


def create_cleanup_lock(p: Path) -> Path:
    lock_path = get_lock_path(p)
    try:
        fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)
    except FileExistsError as e:
        raise OSError(f"cannot create lockfile in {p}") from e
    else:
        pid = os.getpid()
        spid = str(pid).encode()
        os.write(fd, spid)
        os.close(fd)
        if not lock_path.is_file():
            raise OSError("lock path got renamed after successful creation")
        return lock_path


def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):
    pid = os.getpid()

    def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:
        current_pid = os.getpid()
        if current_pid != original_pid:
            # fork
            return
        try:
            lock_path.unlink()
        except OSError:
            pass

    return register(cleanup_on_exit)


def maybe_delete_a_numbered_dir(path: Path) -> None:
    lock_path = None
    try:
        lock_path = create_cleanup_lock(path)
        parent = path.parent

        garbage = parent.joinpath(f"garbage-{uuid.uuid4()}")
        path.rename(garbage)
        rm_rf(garbage)
    except OSError:
        pass
    finally:
        if lock_path is not None:
            try:
                lock_path.unlink()
            except OSError:
                pass


def ensure_deletable(path: Path) -> bool:
    if path.is_symlink():
        return False
    lock = get_lock_path(path)
    try:
        if not lock.is_file():
            return True
    except OSError:
        return False
    try:
        lock_time = lock.stat().st_mtime
    except Exception:
        return False
    else:
        if lock_time < time.time() - LOCK_TIMEOUT:
            lock.unlink()
            return True
        return False


def try_cleanup(path: Path) -> None:
    if ensure_deletable(path):
        maybe_delete_a_numbered_dir(path)


def cleanup_numbered_dir(root: Path, prefix: str, keep: int) -> None:
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
    max_delete = max_existing - keep
    entries = find_prefixed(root, prefix)
    entries, entries2 = itertools.tee(entries)
    numbers = map(parse_num, extract_suffixes(entries2, prefix))
    for entry, number in zip(entries, numbers):
        if number <= max_delete:
            try_cleanup(entry.path)


def cleanup_dead_symlinks(root: Path):
    for left_dir in root.iterdir():
        if left_dir.is_symlink():
            if not left_dir.resolve().exists():
                left_dir.unlink()


def cleanup_numbered_dir_and_dead_symlinks(root: Path, prefix: str, keep: int) -> None:
    cleanup_numbered_dir(root, prefix, keep)
    cleanup_dead_symlinks(root)


def make_numbered_dir_with_cleanup(
    root: Path, prefix: str, keep: int, lock_timeout: float, mode: int
) -> Path:
    p = make_numbered_dir(root, prefix, mode)
    lock_path = create_cleanup_lock(p)
    register_cleanup_lock_removal(lock_path, register=weakref.finalize)
    consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout
    atexit.register(
        cleanup_numbered_dir_and_dead_symlinks,
        root,
        prefix,
        keep,
        consider_lock_dead_if_created_before,
    )
    return p
