"""Utilities for truncating assertion output."""

import typing as t

from _pytest.assertion import util
from _pytest.config import Config
from _pytest.nodes import Item

DEFAULT_MAX_LINES = 8
DEFAULT_MAX_CHARS = 8 * 80
USAGE_MSG = "use '-vv' to show"


def truncate_if_required(
    explanation: t.List[str], item: Item, max_length: t.Optional[int] = None
) -> t.List[str]:
    """Truncate this assertion explanation if the given test item is eligible.

    Args:
        explanation (List[str]): The assertion explanation to truncate.
        item (Item): The pytest item for which the assertion explanation is generated.
        max_length (Optional[int]): The maximum number of lines or characters to keep.
            If None, the default values will be used.

    Returns:
        List[str]: The truncated assertion explanation.
    """
    if _should_truncate_item(item):
        return _truncate_explanation(explanation, max_length)
    return explanation


def _should_truncate_item(item: Item) -> bool:
    """Whether or not this test item is eligible for truncation.

    Args:
        item (Item): The pytest item for which the assertion explanation is generated.

    Returns:
        bool: True if the assertion explanation should be truncated, False otherwise.
    """
    verbose = item.config.get_verbosity(Config.VERBOSITY_ASSERTIONS)
    return verbose < 2 and not util.running_on_ci()


def _truncate_explanation(
    input_lines: t.List[str],
    max_length: t.Optional[int] = None,
) -> t.List[str]:
    """Truncate given list of strings that makes up the assertion explanation.

    Truncates to either 8 lines, or 640 characters - whichever the input reaches
    first, taking the truncation explanation into account. The remaining lines
    will be replaced by a usage message.

    Args:
        input_lines (List[str]): The assertion explanation as a list of lines.
        max_length (Optional[int]): The maximum number of lines or characters to keep.
            If None, the default values will be used.

    Returns:
        List[str]: The truncated assertion explanation.
    """
    if max_length is None:
        max_lines = DEFAULT_MAX_LINES
        max_chars = DEFAULT_MAX_CHARS
    else:
        max_lines, max_chars = _get_max_lines_and_chars(max_length, len(input_lines))

    if len(input_lines) <= max_lines and len("".join(input_lines)) <= max_chars:
        return input_lines

    truncated_explanation = input_lines[:max_lines]
    if len("".join(truncated_explanation)) > max_chars:
        truncated_explanation = _truncate_by_char_count(truncated_explanation, max_chars)

    truncated_line_count = len(input_lines) - len(truncated_explanation)
    if truncated_explanation[-1]:
        truncated_explanation[-1] += "..."
    else:
        truncated_explanation[-1] = "..."

    return (
        truncated_explanation
        + [
            "",
            f"...Full output truncated ({truncated_line_count} line{'s' if truncated_line_count > 1 else ''} hidden), {USAGE_MSG}",
        ]
    )


def _get_max_lines_and_chars(max_length: int, input_lines_length: int) -> t.Tuple[int, int]:
    """Calculate the maximum number of lines and characters based on the input.

    Args:
        max_length (int): The maximum number of lines or characters to keep.
        input_lines_length (int): The length of the input lines.

    Returns:
        Tuple[int, int]: A tuple containing the maximum number of lines and characters.
    """
    if max_length <= DEFAULT_MAX_LINES:
        return max_length, DEFAULT_MAX_CHARS
    return DEFAULT_MAX_LINES, max_length - (DEFAULT_MAX_LINES - input_lines_length)


def _truncate_by_char_count(input_lines: t.List[str], max_chars: int) -> t.List[str]:
    """Truncate the input lines by character count.

    Args:
        input_lines (List[str]): The input lines to truncate.
        max_chars (int): The maximum number of characters to keep.

    Returns:
        List[str]: The truncated input lines.
    """
    iterated_char_count = 0
    for iterated_index, input_line in enumerate(input_lines):
        if iterated_char_count + len(input_line) > max_chars:
            break
        iterated_char_count += len(input_line)

    truncated_result = input_lines[:iterated_index]
    if iterated_index < len(input_lines):
        final_line_truncate_point = max_chars - iterated_char_count
        truncated_result.append(input_lines[iterated_index][:final_line_truncate_point])

    return truncated_result
