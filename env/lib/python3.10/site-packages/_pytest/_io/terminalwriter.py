"""Helper functions for writing to terminals and files."""

import os
import shutil
import sys
from typing import Dict
from typing import Final
from typing import Literal
from typing import Optional
from typing import Sequence
from typing import TextIO
from typing import Type

from .wcwidth import wcswidth

# This code was initially copied from py 1.8.1, file _io/terminalwriter.py.


def get_terminal_width() -> int:
    """Get the width of the terminal.

    Returns:
        int: The width of the terminal.
    """
    width, _ = shutil.get_terminal_size(fallback=(80, 24))

    # The Windows get_terminal_size may be bogus, let's sanify a bit.
    if width < 40:
        width = 80

    return width


def should_do_markup(file: TextIO) -> bool:
    """Determine if markup should be used.

    Args:
        file (TextIO): The file to check.

    Returns:
        bool: True if markup should be used, False otherwise.
    """
    if os.environ.get("PY_COLORS") == "1":
        return True
    if os.environ.get("PY_COLORS") == "0":
        return False
    if os.environ.get("NO_COLOR"):
        return False
    if os.environ.get("FORCE_COLOR"):
        return True
    return (
        hasattr(file, "isatty") and file.isatty() and os.environ.get("TERM") != "dumb"
    )


class TerminalWriter:
    """Class for writing to terminals and files with markup and syntax highlighting.

    Attributes:
        _esctable (Dict[str, int]): A dictionary of markup styles.
        _file (Optional[TextIO]): The file to write to.
        hasmarkup (bool): True if markup is enabled, False otherwise.
        _current_line (str): The current line being built.
        _terminal_width (Optional[int]): The width of the terminal.
        code_highlight (bool): True if code highlighting is enabled, False otherwise.
    """

    _esctable: Final = dict(
        black=30,
        red=31,
        green=32,
        yellow=33,
        blue=34,
        purple=35,
        cyan=36,
        white=37,
        Black=40,
        Red=41,
        Green=42,
        Yellow=43,
        Blue=44,
        Purple=45,
        Cyan=46,
        White=47,
        bold=1,
        light=2,
        blink=5,
        invert=7,
    )

    def __init__(self, file: Optional[TextIO] = None) -> None:
        """Initialize the TerminalWriter object.

        Args:
            file (Optional[TextIO], optional): The file to write to. Defaults to sys.stdout.
        """
        if file is None:
            file = sys.stdout
        if hasattr(file, "isatty") and file.isatty() and sys.platform == "win32":
            try:
                import colorama
            except ImportError:
                pass
            else:
                file = colorama.AnsiToWin32(file).stream
                assert file is not None
        self._file = file
        self.hasmarkup = should_do_markup(file)
        self._current_line = ""
        self._terminal_width: Optional[int] = None
        self.code_highlight = True

    @property
    def fullwidth(self) -> int:
        """Get or set the full width of the output.

        Returns:
            int: The full width of the output.
        """
        if self._terminal_width is not None:
            return self._terminal_width
        return get_terminal_width()

    @fullwidth.setter
    def fullwidth(self, value: int) -> None:
        """Set the full width of the output.

        Args:
            value (int): The full width of the output.
        """
        self._terminal_width = value

    @property
    def width_of_current_line(self) -> int:
        """Return an estimate of the width so far in the current line.

        Returns:
            int: The width of the current line.
        """
        return wcswidth(self._current_line)

    def markup(self, text: str, **markup: bool) -> str:
        """Apply markup styles to the given text.

        Args:
            text (str): The text to apply markup styles to.
            **markup (bool): The markup styles to apply.

        Returns:
            str: The text with markup styles applied.
        """
        for name in markup:
            if name not in self._esctable:
                raise ValueError(f"unknown markup: {name!r}")
        if self.hasmarkup:
            esc = [self._esctable[name] for name, on in markup.items() if on]
            if esc:
                text = "".join("\x1b[%sm" % cod for cod in esc) + text + "\x1b[0m"
        return text

    def sep(
        self,
        sepchar: str,
        title: Optional[str] = None,
        fullwidth: Optional[int] = None,
        **markup: bool,
    ) -> None:
        """Print a separator line.

        Args:
            sepchar (str): The separator character.
            title (Optional[str], optional): The title to center. Defaults to None.
            fullwidth (Optional[int], optional): The full width of the output. Defaults to None.
            **markup (bool): The markup styles to apply.
        """
        if fullwidth is None:
            fullwidth = self.fullwidth
        # The goal is to have the line be as long as possible
        # under the condition that len(line) <= fullwidth.
        if sys.platform == "win32":
            # If we print in the last column on windows we are on a
            # new line but there is no way to verify/neutralize this
            # (we may not know the exact line width).
            # So let's be defensive to avoid empty lines in the output.
            fullwidth -= 1
        if title is not None:
            # we want 2 + 2*len(fill) + len(title) <= fullwidth
            # i.e.    2 + 2*len(sepchar)*N + len(title) <= fullwidth
            #         2*len(sepchar)*N <= fullwidth - len(title) - 2
            #         N <= (fullwidth - len(title) - 2) // (2*len(sepchar))
            N = max(
                (fullwidth - len(title) - 2) // (2 * len(sepchar.strip())), 1
            )
            fill = sepchar * N
            line = f"{fill} {title} {fill}"
        else:
            # we want len(sepchar)*N <= fullwidth
            # i.e.    N <= fullwidth // len(sepchar)
            line = sepchar * (fullwidth // len(sepchar.strip()))
        # In some situations there is room for an extra sepchar at the right,
        # in particular if we consider that with a sepchar like "_ " the
        # trailing space is not important at the end of the line.
        if len(line) + len(sepchar.rstrip()) <= fullwidth:
            line += sepchar.rstrip()

        self.line(line, **markup)

    def write(self, msg: str, *, flush: bool = False, **markup: bool) -> None:
        """Write the given message to the file.

        Args:
            msg (str): The message to write.
            flush (bool, optional): Whether to flush the file after writing. Defaults to False.
            **markup (bool): The markup styles to apply.
        """
        if msg:
            current_line = msg.rsplit("\n", 1)[-1]
            if "\n" in msg:
                self._current_line = current_line
            else:
                self._current_line += current_line

            msg = self.markup(msg, **markup)

            try:
                self._file.write(msg)
            except UnicodeEncodeError:
                # Some environments don't support printing general Unicode
                # strings, due to misconfiguration or otherwise; in that case,
                # print the string escaped to ASCII.
                # When the Unicode situation improves we should consider
                # letting the error propagate instead of masking it (see #7475
                # for one brief attempt).
                msg = msg.encode("unicode-escape").decode("ascii")
                self._file.write(msg)

            if flush:
                self.flush()

    def line(self, s: str = "", **markup: bool) -> None:
        """Write a line to the file.

        Args:
            s (str, optional): The line to write. Defaults to "".
            **markup (bool): The markup styles to apply.
        """
        self.write(s + "\n", **markup)

    def flush(self) -> None:
        """Flush the file."""
        self._file.flush()

    def reset_markup(self) -> None:
        """Reset the markup styles."""
        self.hasmarkup = should_do_markup(self._file)

    def get_markup(self) -> Dict[str, bool]:
        """Get the current markup styles.

        Returns:
            Dict[str, bool]: The current markup styles.
        """
        markup = {}
        for name, cod in self._esctable.items():
            if self._file.tell() > 0 and self._file.read(3) == "\x1b[{}m".format(cod):
                markup[name] = True
                self._file.seek(-3, 1)
            else:
                markup[name] = False
        return markup

    def set_markup(self, markup: Dict[str, bool]) -> None:
        """Set the markup styles.

        Args:
            markup (Dict[str, bool]): The markup styles to set.
        """
        for name, on in markup.items():
            if on and name not in self._esctable:
                raise ValueError(f"unknown markup: {name!r}")
        if self.hasmarkup:
            esc = [self._esctable[name] for name, on in markup.items() if on]
            if esc:
                self._file.write("".join("\x1b[%sm" % cod for cod in esc))

    def set_code_highlight(self, enable: bool = True) -> None:
        """Enable or disable code highlighting.

        Args:
            enable (bool, optional): Whether to enable code highlighting. Defaults to True.
        """
        self.code_highlight = enable

    def get_code_highlight(self) -> bool:
        """Get the current code highlighting status.

        Returns:
            bool: The current code highlighting status.
        """
        return self.code_highlight

    def write_source(
        self,
        source: str,
        lexer: Literal["diff", "python"] = "python",
        fullwidth: Optional[int] = None,
        **markup: bool,
    ) -> None:
        """Write source code with syntax highlighting.

        Args:
            source (str): The source code to write.
            lexer (Literal["diff", "python"], optional): The lexer to use. Defaults to "python".
            fullwidth (Optional[int], optional): The full width of the output. Defaults to None.
            **markup (bool): The markup styles to apply.
        """
        if fullwidth is None:
            fullwidth = self.fullwidth
        self.sep(
            sepchar="=",
            title="Source Code",
            fullwidth=fullwidth,
            bold=True,
            **markup,
        )
        if not source or not self.code_highlight:
            self.write(source, fullwidth=fullwidth, **markup)
            return

        try:
            from pygments.formatters.terminal import TerminalFormatter
            if lexer == "python":
                from pygments.lexers.python import PythonLexer as Lexer
            elif lexer == "diff":
                from pygments.lexers.diff import DiffLexer as Lexer
            from pygments import highlight
            import pygments.util
        except ImportError:
            self.write(source, fullwidth=fullwidth, **markup)
            return
        else:
            try:
                highlighted: str = highlight(
                    source,
                    Lexer(),
                    TerminalFormatter(
                        bg=os.getenv("PYTEST_THEME_MODE", "dark"),
                        style=os.getenv("PYTEST_THEME"),
                    ),
                )
                # pygments terminal formatter may add a newline when there wasn't one.
                # We don't want this, remove.
                if highlighted[-1] == "\n" and source[-1] != "\n":
                    highlighted = highlighted[:-1]

                # Some lexers will not set the initial color explicitly
                # which may lead to the previous color being propagated to the
                # start of the expression, so reset first.
                self.write("\x1b[0m" + highlighted, fullwidth=fullwidth, **markup)
            except pygments.util.ClassNotFound as e:
                raise UsageError(
                    "PYTEST_THEME environment variable had an invalid value: '{}'. "
                    "Only valid pygment styles are allowed.".format(
                        os.getenv("PYTEST_THEME")
                    )
                ) from e
            except pygments.util.OptionError as e:
                raise UsageError(
                    "PYTEST_THEME_MODE environment variable had an invalid value: '{}'. "
                    "The only allowed values are 'dark' and 'light'.".format(
                        os.getenv("PYTEST_THEME_MODE")
                    )
                ) from
