// Core JavaScript helper functions
'use strict';

/**
 * Creates a new HTML element with the given tag name, parent, and optional
 * children and attributes.
 *
 * @param {string} tagName - The name of the HTML tag to create.
 * @param {Node} parent - The parent node to append the new element to.
 * @param {string|Node} [child] - The text or node to add as a child of the
 * new element.
 * @param {Object} [attributes] - An object containing key-value pairs of
 * attributes to set on the new element.
 */
function quickElement(tagName, parent, child, attributes) {
  const element = document.createElement(tagName);
  if (child) {
    if (typeof child === 'string') {
      const textNode = document.createTextNode(child);
      element.appendChild(textNode);
    } else {
      element.appendChild(child);
    }
  }
  if (attributes) {
    for (const [attribute, value] of Object.entries(attributes)) {
      element.setAttribute(attribute, value);
    }
  }
  parent.appendChild(element);
  return element;
}

/**
 * Removes all child nodes of the given element.
 *
 * @param {Node} element - The element to remove children from.
 */
function removeChildren(element) {
  while (element.hasChildNodes()) {
    element.removeChild(element.lastChild);
  }
}

// ... (findPosX, findPosY, and Date object extensions are unchanged)

/**
 * Parses a date string in the format specified by the given format string.
 *
 * @param {string} dateString - The date string to parse.
 * @param {string} format - The format string to use for parsing.
 * @returns {Date} The parsed date object.
 * @throws {Error} If the date string cannot be parsed.
 */
String.prototype.strptime = function(format) {
  const split_format = format.split(/[.\-/]/);
  const date = this.split(/[.\-/]/);
  let i = 0;
  let day, month, year;
  while (i < split_format.length) {
    switch (split_format[i]) {
      case "%d":
        day = date[i];
        break;
      case "%m":
        month = date[i] - 1;
        break;
      case "%Y":
        year = date[i];
        break;
      case "%y":
        // A %y value in the range of [00, 68] is in the current
        // century, while [69, 99] is in the previous century,
        // according to the Open Group Specification.
        if (parseInt(date[i], 10) >= 69) {
          year = date[i];
        } else {
          year = (new Date(Date.UTC(date[i], 0))).getUTCFullYear() + 100;
        }
        break;
      default:
        throw new Error(`Invalid format character: ${split_format[i]}`);
    }
    ++i;
  }
  // Create Date object from UTC since the parsed value is supposed to be
  // in UTC, not local time. Also, the calendar uses UTC functions for
  // date extraction.
  return new Date(Date.UTC(year, month, day));
};
