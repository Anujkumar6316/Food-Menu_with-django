from django.contrib.auth import get_user_model
from django.contrib.auth.models import Permission, Q
from django.db import models
from typing import Any, ClassVar, Final, NoReturn, Optional, Self, Type, TypeVar

UserModel = get_user_model()
T = TypeVar('T', bound=UserModel)


class BaseBackend:
    """
    A base class for Django authentication backends.
    """

    def authenticate(self, request, **kwargs) -> Optional[UserModel]:
        """
        Authenticate a user with the given credentials.

        Returns a user object if the credentials are valid, None otherwise.
        """
        return None

    def get_user(self, user_id: int) -> Optional[UserModel]:
        """
        Get a user object with the given user id.

        Returns a user object if the id is valid, None otherwise.
        """
        return None

    def get_user_permissions(self, user_obj: T, obj: models.Model = None) -> set:
        """
        Return a set of permission strings the user `user_obj` has from their
        `user_permissions`.
        """
        return set()

    def get_group_permissions(self, user_obj: T, obj: models.Model = None) -> set:
        """
        Return a set of permission strings the user `user_obj` has from the
        groups they belong.
        """
        return set()

    def get_all_permissions(self, user_obj: T, obj: models.Model = None) -> set:
        """
        Return a set of all permissions the user `user_obj` has.
        """
        return {
            *self.get_user_permissions(user_obj, obj=obj),
            *self.get_group_permissions(user_obj, obj=obj),
        }

    def has_perm(self, user_obj: T, perm: str, obj: models.Model = None) -> bool:
        """
        Return True if the user `user_obj` has the permission `perm`.
        """
        return perm in self.get_all_permissions(user_obj, obj=obj)


class ModelBackend(BaseBackend):
    """
    Authenticates against settings.AUTH_USER_MODEL.
    """

    def authenticate(self, request, username: str = None, password: str = None, **kwargs) -> Optional[UserModel]:
        if username is None:
            username = kwargs.get(UserModel.USERNAME_FIELD)
        if username is None or password is None:
            return
        try:
            user = UserModel._default_manager.get_by_natural_key(username)
        except UserModel.DoesNotExist:
            # Run the default password hasher once to reduce the timing
            # difference between an existing and a nonexistent user (#20760).
            UserModel().set_password(password)
        else:
            if user.check_password(password) and self.user_can_authenticate(user):
                return user

    def user_can_authenticate(self, user: T) -> bool:
        """
        Reject users with is_active=False. Custom user models that don't have
        that attribute are allowed.
        """
        return getattr(user, "is_active", True)

    @property
    def perm_cache(self) -> dict:
        """
        A cache of permissions for the current user.
        """
        if not hasattr(self, "_perm_cache"):
            self._perm_cache = {}
        return self._perm_cache

    def _get_user_permissions(self, user_obj: T) -> models.QuerySet[Permission]:
        return user_obj.user_permissions.all()

    def _get_group_permissions(self, user_obj: T) -> models.QuerySet[Permission]:
        user_groups_field = get_user_model()._meta.get_field("groups")
        user_groups_query = f"group__{user_groups_field.related_query_name()}"
        return Permission.objects.filter(**{user_groups_query: user_obj})

    @staticmethod
    def _get_permissions(user_obj: T, obj: models.Model, from_name: str) -> set:
        """
        Return the permissions of `user_obj` from `from_name`. `from_name` can
        be either "group" or "user" to return permissions from
        `_get_group_permissions` or `_get_user_permissions` respectively.
        """
        if not user_obj.is_active or user_obj.is_anonymous or obj is not None:
            return set()

        perm_cache_name = f"_perm_cache_{from_name}"
        if perm_cache_name not in user_obj.__dict__:
            if user_obj.is_superuser:
                perms = Permission.objects.all()
            else:
                perms = getattr(ModelBackend(), f"_get_{from_name}_permissions")(user_obj)
            perms = perms.values_list("content_type__app_label", "codename").order_by()
            user_obj.__dict__[perm_cache_name] = {f"{ct}.{name}" for ct, name in perms}
        return user_obj.__dict__[perm_cache_name]

    def get_user_permissions(self, user_obj: T, obj: models.Model = None) -> set:
        """
        Return a set of permission strings the user `user_obj` has from their
        `user_permissions`.
        """
        return self._get_permissions(user_obj, obj, "user")

    def get_group_permissions(self, user_obj: T, obj: models.Model = None) -> set:
        """
        Return a set of permission strings the user `user_obj` has from the
        groups they belong.
        """
        return self._get_permissions(user_obj, obj, "group")

    def get_all_permissions(self, user_obj: T, obj: models.Model = None) -> set:
        if not user_obj.is_active or user_obj.is_anonymous or obj is not None:
            return set()
        if "_perm_cache" not in user_obj.__dict__:
            user_obj.__dict__["_perm_cache"] = super().get_all_permissions(user_obj)
        return user_obj.__dict__["_perm_cache"]

    def has_perm(self, user_obj: T, perm: str, obj: models.Model = None) -> bool:
        return user_obj.is_active and super().has_perm(user_obj, perm, obj=obj)

    def has_module_perms(self, user_obj: T, app_label: str) -> bool:
        """
        Return True if user_obj has any permissions in the given app_label.
        """
        return user_obj.is_active and any(
            perm[: perm.index(".")] == app_label
            for perm in self.get_all_permissions(user_obj)
        )

    @classmethod
    def with_perm(cls, perm: str, is_active: bool = True, include_superusers: bool = True, obj: models.Model = None) -> models.QuerySet[UserModel]:
        """
        Return users that have permission "perm". By default, filter out
        inactive users and include superusers.
        """
        if isinstance(perm, str):
            try:
                app_label, codename = perm.split(".")
            except ValueError:
                raise ValueError(
                    "Permission name should be in the form "
                    "app_label.permission_codename."
                )
        elif not isinstance(perm, Permission):
            raise TypeError(
                "The `perm` argument must be a string or a permission instance."
            )

        if obj is not None:
            return UserModel._default_manager.none()

        permission_q = Q(group__user=models.OuterRef("pk")) | Q(user=models.OuterRef("pk"))
        if isinstance(perm, Permission):
            permission_q &= Q(pk=perm.pk)
        else:
            permission_q &= Q(codename=codename, content_type__app_label=app_label)

        user_q = models.Exists(Permission.objects.filter(permission_q))
        if include_superusers:
            user_q |= Q(is_superuser=True)
        if is_active is not None:
            user_q &= Q(is_active=is_active)

        return UserModel._default_manager.filter(user_q)

    def get_user(self, user_id: int) -> Optional[UserModel]:
        try:
            user = UserModel._default_manager.get(pk=user_id)
        except UserModel.DoesNotExist:
            return None
        return user if self.user_can_authenticate(user) else None


class AllowAllUsersModelBackend(ModelBackend):
    def user_can_authenticate(self, user: T) -> bool:
        return True


class RemoteUserBackend(ModelBackend):
    """
    This backend is to be used in conjunction with the ``RemoteUserMiddleware``
    found in the middleware module of this package, and is used when the server
    is handling authentication outside of Django.

    By default, the ``authenticate`` method creates ``User`` objects for
    usernames that don't already exist in the database.  Subclasses can disable
    this behavior by setting the ``create_unknown_user`` attribute to
    ``False``.
    """

    create_unknown_user: Final[bool] = True

    def authenticate(self, request, remote_user: Optional[str]) -> Optional[UserModel]:
        """
        The username passed as ``remote_user`` is considered trusted. Return
        the ``User`` object with the given username. Create a new ``User``
        object if ``create_unknown_user`` is ``True``.

        Return None if ``create_unknown_user`` is ``False`` and a ``User``
        object with the given username is not found in the database.
        """
        if not remote_user:
            return
        created = False
        user = None
        username = self.clean_username(remote_user)

        # Note that this could be accomplished in one try-except clause, but
        # instead we use get_or_create when creating unknown users since it has
        # built-in safeguards for multiple threads.
        if self.create_unknown_user:
            user, created = UserModel._default_manager.get_or_create(
                **{UserModel.USERNAME_FIELD: username}
            )
        else:
            try:
                user = UserModel._default_manager.get_by_natural_key(username)
            except UserModel.DoesNotExist:
                pass
        user = self.configure_user(request, user, created=created)
        return user if self.user_can_authenticate(user) else None

    def clean_username(self, username: str) -> str:
        """
        Perform any cleaning on the "username" prior to using it to get or
        create the user object.  Return the cleaned username.

        By default, return the username unchanged.
        """
        return username

    def configure_user(self, request: Any, user: T, created: bool = True) -> T:
        """
        Configure a user and return the updated user.

        By default, return the user unmodified.
        """
        return user

    def user_can_authenticate(self, user: T) -> NoReturn:
        """
        Always return True for this backend.
        """
        return True


class AllowAllUsersRemoteUserBackend(RemoteUserBackend):
    def user_can_authenticate(self, user: T) -> NoReturn:
        """
        Always return True for this backend.
        """
        return True
